import json
import pathlib
from collections import defaultdict
from typing import Union, Dict, Iterator

import click

from sigma.cli.rules import load_rules
from sigma.analyze.attack import score_functions, calculate_attack_scores
from sigma.data.mitre_attack import mitre_attack_techniques_tactics_mapping, mitre_attack_version
from sigma.modifiers import *
from sigma.rule import SigmaDetection, SigmaDetectionItem

@click.group(name="analyze", help="Analyze Sigma rule sets")
def analyze_group():
    pass

@analyze_group.command(
        name="attack",
        help="Create MITRE™️ ATT&CK heatmaps from Sigma rule set. Score functions are: " + ", ".join((
            f"{definition[1]} ({func})"
            for func, definition in score_functions.items()
        ))
    )
@click.option(
    "--file-pattern", "-P",
    default="*.yml",
    show_default=True,
    help="Pattern for file names to be included in recursion into directories.",
)
@click.option(
    "--subtechniques/--no-subtechniques", "-s/-S",
    default=True,
)
@click.option(
    "--max-color", "-c",
    default="#ff0000",
    show_default=True,
    help="Color used for maximum score."
)
@click.option(
    "--min-color", "-C",
    default="#ffffff00",
    show_default=True,
    help="Color used for zero score."
)
@click.option(
    "--max-score", "-m",
    type=int,
    default=None,
    help="Set fixed maximum score. All scores above are rendered as maximum. Increases color scale resolution for scores below.",
)
@click.option(
    "--min-score", "-M",
    type=int,
    default="0",
    show_default=True,
    help="Minimum score. All scores below are not explicitly colored.",
)
@click.argument(
    "function",
    type=click.Choice(score_functions.keys()),
)
@click.argument(
    "output",
    type=click.File("w"),
)
@click.argument(
    "input",
    nargs=-1,
    required=True,
    type=click.Path(exists=True, allow_dash=True, path_type=pathlib.Path),
)
def analyze_attack(file_pattern, subtechniques, max_color, min_color, max_score, min_score, function, output, input):
    rules = load_rules(input, file_pattern)
    score_function = score_functions[function][0]
    scores = calculate_attack_scores(rules, score_function, not subtechniques)
    layer_techniques = [
        {
            "techniqueID": technique,
			"tactic": tactic,
			"score": score,
			"color": "",
			"comment": "",
			"enabled": True,
			"metadata": [],
			"links": [],
			"showSubtechniques": False,
        }
        for technique, score in scores.items()
        for tactic in mitre_attack_techniques_tactics_mapping.get(technique, [])
    ]
    layer = {
        "name": "layer",
        "versions": {
            "attack": mitre_attack_version,
            "navigator": "4.8.1",
            "layer": "4.4"
        },
        "domain": "enterprise-attack",
        "description": f"Sigma coverage heatmap generated by Sigma CLI with score function {function}",
        "gradient": {
            "colors": [
                min_color,
                max_color,
            ],
            "minValue": min_score,
            "maxValue": max_score or max(scores.values())
        },
        "techniques": layer_techniques,
    }
    json.dump(layer, output, indent=2)

@analyze_group.command(
        name="fields",
        help="Analyze field usage in Sigma rule set."
    )
@click.option(
    "--file-pattern", "-P",
    default="*.yml",
    show_default=True,
    help="Pattern for file names to be included in recursion into directories.",
)
@click.option(
    "--modifiers/--no-modifiers",
    default=False,
    help="Group by modifiers in addition to fields?"
)
@click.option(
    "--combined/--no-combined",
    default=False,
    help="Combine all fields required for a rule"
)
@click.option(
    "--verbose/--no-verbose",
    default=False,
    help="List rule names instead of showing counts"
)
@click.argument(
    "output",
    type=click.File("w"),
)
@click.argument(
    "input",
    nargs=-1,
    required=True,
    type=click.Path(exists=True, allow_dash=True, path_type=pathlib.Path),
)
def analyze_fields(modifiers, combined, verbose, file_pattern, output, input):
    rules = load_rules(input, file_pattern)

    if verbose:
        rules_by_field = defaultdict(set)
        conditions_by_field = defaultdict(set)
    else:
        rules_by_field = defaultdict(int)
        conditions_by_field = defaultdict(int)

    for rule in rules:
        observed_fields = set()

        for detection in rule.detection.detections.values():
            for field, count in get_conditions_by_field(detection, modifiers):
                observed_fields.add(field)

                if verbose:
                    conditions_by_field[field].add(rule.title)
                else:
                    conditions_by_field[field] += count

        if combined:
            fields = ",".join(sorted(observed_fields))

            if verbose:
                rules_by_field[fields].add(rule.title)
            else:
                rules_by_field[fields] += 1
        else:
            for field in observed_fields:
                if verbose:
                    rules_by_field[field].add(rule.title)
                else:
                    rules_by_field[field] += 1

    if verbose:
        key = lambda v: len(v[1])
    else:
        key = lambda v: v[1]

    layer = {
        'rules_by_field': dict(sorted(rules_by_field.items(), key=key, reverse=True)),
    }

    if not combined:
        layer['conditions_by_field'] = dict(sorted(conditions_by_field.items(), key=key, reverse=True))

    json.dump(layer, output, indent=2, default=lambda v: list(sorted(v)))

def get_conditions_by_field(detection: Union[SigmaDetection, SigmaDetectionItem], modifiers : bool) -> Dict[str, int]:
    modifier_to_keyword = {
        SigmaStartswithModifier: "|startswith",
        SigmaEndswithModifier: "|endswith",
        SigmaContainsModifier: "|contains",
        SigmaBase64OffsetModifier: "|base64offset",
        SigmaBase64Modifier: "|base64",
    }
    if type(detection) == SigmaDetectionItem:
        field = detection.field or "__keywords__"

        if modifiers:
            for modifier in detection.modifiers:
                field += modifier_to_keyword.get(modifier, "")

        yield field, len(detection.value)

    elif type(detection) == SigmaDetection:
        for item in detection.detection_items:
            yield from get_conditions_by_field(item, modifiers)


@analyze_group.command(
        name="categories",
        help="Analyze EventIDs for each category in Sigma rule set."
    )
@click.option(
    "--file-pattern", "-P",
    default="*.yml",
    show_default=True,
    help="Pattern for file names to be included in recursion into directories.",
)
@click.argument(
    "output",
    type=click.File("w"),
)
@click.argument(
    "input",
    nargs=-1,
    required=True,
    type=click.Path(exists=True, allow_dash=True, path_type=pathlib.Path),
)
def analyze_categories(file_pattern, output, input):
    rules = load_rules(input, file_pattern)

    events_by_category = defaultdict(lambda: defaultdict(int))

    for rule in rules:
        category = rule.logsource.category or "unknown"

        for detection in rule.detection.detections.values():
            for event_id in get_event_ids(detection):
                events_by_category[category][event_id] += 1

    layer = {
        'events_by_category': {
            category: dict(sorted(count_by_event.items(), key=lambda i: i[1], reverse=True))
                for category, count_by_event in events_by_category.items()
        },
    }

    json.dump(layer, output, indent=2)

def get_event_ids(detection: Union[SigmaDetection, SigmaDetectionItem]) -> Iterator[str]:
    if type(detection) == SigmaDetectionItem:
        if detection.field and detection.field.lower() in ("eventid", "event_id"):
            for value in detection.value:
                yield str(value)

    elif type(detection) == SigmaDetection:
        for item in detection.detection_items:
            yield from get_event_ids(item)
